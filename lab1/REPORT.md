# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Абросимов А.Д.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|   21.10      |       4       |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

Задание 1.1. отсутствует реализация через стандартные предикаты.

## Введение

В Prologе списки представлены двумя элементами: головой и хвостом.Это позволяет обрабатывать любые списки простым образом. Следствием этого является время доступа к элементу 
'(O(n))'

## Задание 1.1: Предикат обработки списка

`task(X,R)` - удаляет первые три элемента из списка

Примеры использования:
```prolog
?- task([1,2,3,4,5,6],R).
R = [4, 5, 6].

Реализация:
```prolog
task([],[]).
task(X,R):-X=[_,_,_|R].

Предикат данный список представляет в виде последовательности из трёх каких-то элементов и хвоста.Хвост и есть список без первых трёх эл-ов

## Задание 1.2: Предикат обработки числового списка

'task2(X,R)' - считает кол-во вхождений первого эл-та

Примеры использования:
```prolog
?- task2([1,2,3,1,1,1],R).
R = 4.
?- task2([1,2,3],R).
R = 1.
?- task2([],R).
R = 0.

Реализация:
```prolog
task2([],0).
task2([H|T],R):-delete(T,H,T1),length(T1,R1),length([H|T],R2),R is R2-R1.

## Задание 2: Реляционное представление данных
Преимузества реляционного представления в целом:
* Удобно хранить данные, менять их и добавлять
* Требуется всего лишь несколько преобразований, чтобы отобразить данные в удобочитаемом виде

Недостатки реляционного представления в целом:
* В некоторых задачах требуется слишком много времени для поиска информации и связей между ними
* При комплексных структурах данных, требуется значительное время, чтобы найти всю информацию об одном объекте
* Довольно трудно хранить неструктурированную информацию(такую как информация в текстах, книгах)

Преимущества представления, используемого мной:
* Данный вид представления крайне удобно использовать, имея уже полный набор данных


`avg(List, R)` - считает среднее арифметическое числового списка `List` и записывает результат в `R`.

Примеры использования:
```prolog
?- avg([1, 2, 3, 4], X).
X=2.5.
```

Реализация:
```prolog
avg(List, R) :- length(List, Len), sum_list(List, Sum), Len > 0, R is Sum/Len.
```
Сначала находится длина списка Len, суммируются все числа в этом списке, и ,если длина больше нуля, результат равен сумме,разделенной на длину

`scores(Student, Res)` - выводит все оценки указанного студента `Student` в `R`.

Примеры использования:

```prolog
?- scores('Мышин', Res).
Res = 3 ;
Res = 5 ;
Res = 5 ;
Res = 5 ;
Res = 5 ;
Res = 4 ;
false.

?- scores(X, 2).
X = 'Петровский' ;
X = 'Сидоров' ;
X = 'Джаво' ;
X = 'Петров' ;
X = 'Сиплюсплюсов' ;
X = 'Криптовалютников' ;
X = 'Решетников' ;
X = 'Азурин' ;
X = 'Безумников' ;
X = 'Круглосчиталкин' ;
false.
```

Реализация:
```prolog
scores(Student, R) :- subject(_, X), member(grade(Student, R), X).
```

Данный предикат вычленяет список из каждого предмета, затем проверяет, есть ли студент с указанной оценкой в списке предмета с помощью встроенного предиката `member\2`.


`average_score_by_student(Student, R)` - считает среднюю оценку для каждого студента.

Пример использования:
```prolog
?- avg_score_by_student('Мышин', Res).
Res = 4.5.
```
Реализация:
```prolog
avg_score_by_student(Student, R) :- findall(N, scores(Student, N), L), avg(L, R).
```

Данный предикат находит все оценки у данного студента `Student` и записывает их в список, который затем передается в предикат `avg` для подсчета среднего арифметического данного числового списка и записывает ответ в `Res`.

`avg_score_every_student(Group, Res)` - считает среднее арифметическое для каждого студента из указанной группы.

Пример использования:
```prolog
?- average_score_every_student(101, Res).
Res = 3.6666666666666665 ;
Res = 3.6666666666666665 ;
Res = 4.5 ;
Res = 3.6666666666666665 ;
Res = 4.333333333333333.
```

Реализация:
```prolog
avg_score_every_student(Group, Res) :- group(Group, List), member(S, List), avg_score_by_student(S, Res).
```

Данный предикат берет список студентов из указанной группы, а затем проходит по каждому элементу списка(по каждому студенту из группы) и считает среднее значение оценок у студента.

`average_score_by_group(Group, Ans)` - считает среднее арифметическое оценок для данной группы `Group` и записывает ответ в `Ans`.

Пример использования:
```prolog
?- avg_score_by_group(101, Res).
Res = 3.9666666666666663.
?- avg_score_by_group(X, Res).
X = 102,
Res = 3.9444444444444446 ;
X = 101,
Res = 3.9666666666666663 ;
\
```

Реализация:
```prolog
avg_score_by_group(Group, Ans) :- group(Group, _), findall(Res, avg_score_every_student(Group, Res), ListAvg), avg(ListAvg, Ans).
```

Данный предикат удостоверяется, что есть указанная группа и, затем считает среднее для каждого студента из группы, занося найденные ответы из предыдущего предиката в список , а затем считая среднее арифметическое с помощью предиката `avg`.

`with_score_by_subject(Sub, Score, Name)` - ищет студента, у которого оценка по предмету `Sub` равна `Score`.

Примеры использования:
```prolog
?- with_score_by_subject('Логическое программирование', 4, Stud).
Stud = 'Петров' ;
Stud = 'Сидоркин' ;
Stud = 'Биткоинов' ;
Stud = 'Сиплюсплюсов' ;
Stud = 'Программиро' ;
Stud = 'Круглосчиталкин' ;
Stud = 'Эксель' ;
Stud = 'Текстописов' ;
false.
```
Реализация:
```prolog
with_score_by_subject(Sub, Score, Name) :- subject(Sub, Students), member(grade(Name, Score), Students).
```

Данный предикат вычленяет список студентов из указанного предмета `Sub`, затем ищет студента, у которого по данному предмету данная оценка `Score` с помощью встроенного предиката `member`, который проверяет принадлежность к списку, и возвращает имя студента в качестве ответа.

`failed_students_by_subject(Sub, Name)` - находит студента, у которого по данному предмету `Sub` оценка 2 и выводит имя студента в переменную `Name`.

Пример использования:
```prolog
?- failed_students_by_subject('Логическое программирование', Ans).
Ans = 'Петровский' ;
Ans = 'Сидоров' ;
Ans = 'Джаво' ;
false.

?- failed_students_by_subject(Sub, 'Петров').
Sub = 'Математический анализ' ;
false.
```

Реализация:
```prolog
failed_students_by_subject(Sub, Name) :- with_score_by_subject(Sub, 2, Name).
```

Данный предикат использует предыдущий предикат, но конкретизирует оценку в виде числа 2.

`list_failed_students_by_subject(Sub, ListNames)` - ищет учеников, которые не сдали указанный предмет `Sub` и записывает их в список `ListNames`.

Пример использования:

```prolog
?- list_failed_students_by_subject(Sub, Studs).
Sub = 'Логическое программирование',
Studs = ['Петровский', 'Сидоров', 'Джаво'] ;
Sub = 'Математический анализ',
Studs = ['Петров'] ;
Sub = 'Функциональное программирование',
Studs = [] ;
Sub = 'Информатика',
Studs = ['Сиплюсплюсов', 'Криптовалютников'] ;
Sub = 'Английский язык',
Studs = ['Решетников', 'Азурин'] ;
Sub = 'Психология',
Studs = ['Безумников', 'Круглосчиталкин'].

?- list_failed_students_by_subject('Психология', Studs).
Studs = ['Безумников', 'Круглосчиталкин'].

?- list_failed_students_by_subject(Sub, []).
Sub = 'Функциональное программирование' ;
false.
```

Реализация:
```prolog
list_failed_students_by_subject(Sub, ListNames) :- subject(Sub, _), findall(Stud, failed_students_by_subject(Sub, Stud), ListNames).
```
Данный предикат удостоверяется, что данный предмет существует, затем ищет всех студентов, которые провалили указанный предмет `Sub` с помощью встроенного предиката `findall` и запоминает результат в перменую `ListNames`.

`with_score_by_group(Group, Score, Name)` - ищет студента, у которого оценка в группе `Group` равна `Score`.

Примеры использования:
```prolog
?- with_score_by_group(101, 3, Name).
Name = 'Петровский' ;
Name = 'Петровский' ;
Name = 'Сидоров' ;
Name = 'Сидоров' ;
Name = 'Мышин' ;
Name = 'Безумников' ;
Name = 'Безумников' ;
Name = 'Густобуквенникова' ;
false.

?- with_score_by_group(Gr, 2, 'Джаво').
Gr = 104 ;
false.
```

Реализация:
```prolog
with_score_by_group(Group, Score, Name) :- group(Group, Students), member(Name, Students), with_score_by_subject(_, Score, Name).
```

Данный предикат использует предикат нахождения студентов по предмету с указанной оценкой `Score` и для улосвия причастности студента к группе, также использует предикат group, а также ищет студента с данным именем `Name` в списке студентов указанной группы.

`failed_students_by_group(Group, Name)` - предикат ищет студентов, проваливших экзамен, в указанной группе `Group`.

Пример использования:
```prolog
?- failed_students_by_group(101, N).
N = 'Петровский' ;
N = 'Сидоров' ;
N = 'Безумников' ;
false.

?- failed_students_by_group(G, 'Петровский').
G = 101 ;
false.
```

Реализация:
```prolog
failed_students_by_group(Group, Name) :- with_score_by_group(Group, 2, Name).
```

Данный предикат просто использует предыдущий, с явным указанием оценки, равной числу 2.

`count_failed_students_by_group(Group, Count)` - считает количество студентов, проваливших экзамены в данной группе `Group`.

Пример использования:
```prolog
?- count_failed_students_by_group(104, C).
C = 2.

?- count_failed_students_by_group(102, C).
C = 3.

?- count_failed_students_by_group(103, C).
C = 2.

?- count_failed_students_by_group(G, 2).
G = 104 ;
G = 103.
```
Реализация:
```prolog
count_failed_students_by_group(Group, Count) :- group(Group, _), setof(Name, failed_students_by_group(Group, Name), Students), length(Students, Count).
```

Данный предикат сначала проверяет наличие указанной группы `Group`, затем с помощью предиката `setof`, ищет всех уникальных студентов, проваливших экзамен в данной группе, и запоминает их в список `Students`, длина которого затем высчитывается предикатом `length` и результат записывается в перменную `Count`.
## Выводы

Лабораторная работа показала мне принципиально новый подход к программированию в целом. Она помогла понять, как нужно работать с списками в логических языках программирования.Также данная лабораторная работа научила меня находить шаблоны запросов к данным, которые представленны не всегда в удобном формате для данного вида запроса. 


